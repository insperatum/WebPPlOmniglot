'use strict';
var ad = require('../../../webppl/src/ad.js');
var Canvas = require('canvas');
var fs = require('fs');
var ad;
var Tensor;
var nn;
var width = 32;
module.exports = {
    init: function (ad_, Tensor_, nn_) {
        ad = ad_;
        Tensor = Tensor_;
        nn = nn_;
        var fill = ad.newFunction({
            OutputType: Tensor,
            name: 'create',
            forward: function (w, h, val) {
                var t = ad.lift(new Tensor([
                    1,
                    w,
                    h
                ]).fill(ad.value(val)));
                var lineLength = ad.lift(0);
                return {
                    t: t,
                    lineLength: lineLength,
                    overlap: 0
                };
            },
            backward: function (w, h, val) {
                val.dx = this.t.dx.sumreduce();
            },
            getParents: function (w, h, val) {
                return ad.isLifted(val) ? [val] : [];
            }
        });
        var drawLine = function (adcanvas, p1, p2, linewidth, alpha) {
            var w = ad.value(adcanvas.t).dims[1];
            var h = ad.value(adcanvas.t).dims[2];
            var pixels = [];
            var pixels = ad.tensor.toScalars(adcanvas.t);
            var v_y1 = ad.value(p1.y);
            var v_y2 = ad.value(p2.y);
            var v_x1 = ad.value(p1.x);
            var v_x2 = ad.value(p2.x);
            var lower = ad.scalar.div(ad.scalar.sub(linewidth, 1), 2);
            var yMin = ad.scalar.max(0, ad.scalar.floor(ad.scalar.sub(ad.scalar.sub(ad.scalar.min(v_y1, v_y2), lower), 1)));
            var yMax = ad.scalar.min(h, ad.scalar.ceil(ad.scalar.add(ad.scalar.add(ad.scalar.max(v_y1, v_y2), lower), 1)));
            var xMin = ad.scalar.max(0, ad.scalar.floor(ad.scalar.sub(ad.scalar.sub(ad.scalar.min(v_x1, v_x2), lower), 1)));
            var xMax = ad.scalar.min(w, ad.scalar.ceil(ad.scalar.add(ad.scalar.add(ad.scalar.max(v_x1, v_x2), lower), 1)));
            for (var y = yMin; ad.scalar.lt(y, yMax); y++) {
                for (var x = xMin; ad.scalar.lt(x, xMax); x++) {
                    i = ad.scalar.add(x, ad.scalar.mul(w, y));
                    pixels[i] = drawPixelIntensity(pixels[i], x, y, p1.x, p1.y, p2.x, p2.y, lower, alpha);
                }
            }
            var xdiff = ad.scalar.sub(p1.x, p2.x);
            var ydiff = ad.scalar.sub(p1.y, p2.y);
            var len = ad.scalar.sqrt(ad.scalar.add(ad.scalar.mul(xdiff, xdiff), ad.scalar.mul(ydiff, ydiff)));
            var lineLength = ad.scalar.add(adcanvas.lineLength, len);
            var vector = ad.tensor.fromScalars(pixels);
            var output = ad.tensor.reshape(vector, [
                1,
                w,
                h
            ]);
            return {
                t: output,
                lineLength: lineLength
            };
        };
        var closestDistance = function (x, y, x1, y1, x2, y2) {
            var xdiff = ad.scalar.sub(x2, x1);
            var ydiff = ad.scalar.sub(y2, y1);
            var len = ad.scalar.sqrt(ad.scalar.add(ad.scalar.mul(xdiff, xdiff), ad.scalar.mul(ydiff, ydiff)));
            var projection = ad.scalar.div(ad.scalar.add(ad.scalar.mul(ad.scalar.sub(x, x1), xdiff), ad.scalar.mul(ad.scalar.sub(y, y1), ydiff)), len);
            if (ad.scalar.lt(projection, 0)) {
                return ad.scalar.sqrt(ad.scalar.add(ad.scalar.pow(ad.scalar.sub(x, x1), 2), ad.scalar.pow(ad.scalar.sub(y, y1), 2)));
            } else if (ad.scalar.gt(projection, len)) {
                return ad.scalar.sqrt(ad.scalar.add(ad.scalar.pow(ad.scalar.sub(x, x2), 2), ad.scalar.pow(ad.scalar.sub(y, y2), 2)));
            } else {
                return ad.scalar.div(ad.scalar.abs(ad.scalar.sub(ad.scalar.add(ad.scalar.sub(ad.scalar.mul(ydiff, x), ad.scalar.mul(xdiff, y)), ad.scalar.mul(x2, y1)), ad.scalar.mul(y2, x1))), len);
            }
        };
        var drawPixelIntensity = function (currentvalue, x, y, x1, y1, x2, y2, lower, alpha) {
            var d = closestDistance(x, y, x1, y1, x2, y2);
            if (ad.scalar.lt(d, lower)) {
                return ad.scalar.sub(1, ad.scalar.mul(ad.scalar.sub(1, currentvalue), ad.scalar.sub(1, alpha)));
            } else if (ad.scalar.lt(d, ad.scalar.add(lower, 1))) {
                return ad.scalar.sub(1, ad.scalar.mul(ad.scalar.sub(1, currentvalue), ad.scalar.sub(1, ad.scalar.mul(ad.scalar.sub(ad.scalar.add(lower, 1), d), alpha))));
            } else {
                return currentvalue;
            }
        };
        var saveImage = function (adcanvas, filename, colour) {
            if (colour === undefined) {
                colour = [
                    255,
                    255,
                    255
                ];
            }
            var tens = ad.value(adcanvas.t);
            var w = tens.dims[1];
            var h = tens.dims[2];
            var canvas = new Canvas(w, h);
            var ctx = canvas.getContext('2d');
            var imageData = ctx.createImageData(w, h);
            for (var x = 0; x < w; x++) {
                for (var y = 0; y < h; y++) {
                    imageData.data[4 * (y + x * h) + 0] = 255 * tens.get([
                        0,
                        x,
                        y
                    ]) * colour[0];
                    imageData.data[4 * (y + x * h) + 1] = 255 * tens.get([
                        0,
                        x,
                        y
                    ]) * colour[1];
                    imageData.data[4 * (y + x * h) + 2] = 255 * tens.get([
                        0,
                        x,
                        y
                    ]) * colour[2];
                    imageData.data[4 * (y + x * h) + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            fs.writeFileSync(filename, canvas.toBuffer());
        };
        var saveOverlay = function (adcanvas1, adcanvas2, filename, colour1, colour2) {
            if (colour1 === undefined) {
                colour = [
                    255,
                    255,
                    255
                ];
            }
            if (colour2 === undefined) {
                colour = [
                    255,
                    255,
                    255
                ];
            }
            var tens1 = ad.value(adcanvas1.t);
            var tens2 = ad.value(adcanvas2.t);
            var w = tens1.dims[1];
            var h = tens1.dims[2];
            var canvas = new Canvas(w, h);
            var ctx = canvas.getContext('2d');
            var imageData = ctx.createImageData(w, h);
            for (var x = 0; x < w; x++) {
                for (var y = 0; y < h; y++) {
                    imageData.data[4 * (y + x * h) + 0] = 255 * (1 - (1 - tens1.get([
                        0,
                        x,
                        y
                    ]) * colour1[0]) * (1 - tens2.get([
                        0,
                        x,
                        y
                    ]) * colour2[0]));
                    imageData.data[4 * (y + x * h) + 1] = 255 * (1 - (1 - tens1.get([
                        0,
                        x,
                        y
                    ]) * colour1[1]) * (1 - tens2.get([
                        0,
                        x,
                        y
                    ]) * colour2[1]));
                    imageData.data[4 * (y + x * h) + 2] = 255 * (1 - (1 - tens1.get([
                        0,
                        x,
                        y
                    ]) * colour1[2]) * (1 - tens2.get([
                        0,
                        x,
                        y
                    ]) * colour2[2]));
                    imageData.data[4 * (y + x * h) + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            fs.writeFileSync(filename, canvas.toBuffer());
        };
        var gaussianKernel = function (sd) {
            var w = 2 * sd + 1;
            var kernel = new Tensor([
                1,
                w,
                w
            ]);
            var variance = sd * sd;
            for (var x = 0; x < w; x++) {
                for (var y = 0; y < w; y++) {
                    var xdiff = x - (w - 1) / 2;
                    var ydiff = y - (w - 1) / 2;
                    kernel.data[x + y * w] = Math.exp(-(xdiff * xdiff + ydiff * ydiff) / variance);
                }
            }
            kernel = ad.tensor.div(kernel, kernel.sumreduce());
            return kernel;
        };
        var powKernel = function (w, pow) {
            var kernel = new Tensor([
                1,
                w,
                w
            ]);
            for (var x = 0; x < w; x++) {
                for (var y = 0; y < w; y++) {
                    var xdiff = (x - (w - 1) / 2) / w;
                    var ydiff = (y - (w - 1) / 2) / w;
                    kernel.data[x + y * w] = Math.pow(1 + xdiff * xdiff + ydiff * ydiff, pow / 2);
                }
            }
            kernel = ad.tensor.div(kernel, kernel.sumreduce());
            return kernel;
        };
        var convolve = function (adcanvas, filter) {
            var tens = ad.value(adcanvas.t);
            var w = tens.dims[1];
            var h = tens.dims[2];
            var fw = filter.dims[1];
            var fh = filter.dims[2];
            var t = nn.convolve(adcanvas.t, filter.clone().reshape([
                1,
                1,
                fw,
                fh
            ]), new Tensor([
                1,
                w,
                h
            ]), 1, 1, (fw - 1) / 2, (fh - 1) / 2);
            return {
                t: t,
                lineLength: adcanvas.lineLength,
                overlap: adcanvas.overlap
            };
        };
        var getEnd = function (startPoint, controlPoints) {
            var coords = [
                interpolate(0, 3, [{
                        x: 0,
                        y: 0
                    }].concat(controlPoints)),
                interpolate(1, 3, [{
                        x: 0,
                        y: 0
                    }].concat(controlPoints))
            ];
            return {
                x: startPoint.x - coords[0].x + coords[1].x,
                y: startPoint.y - coords[0].y + coords[1].y
            };
        };
        var drawStroke = function (adcanvas, startPoint, controlPoints, linewidth, alpha) {
            var out = adcanvas;
            var ts = [
                0,
                0.2,
                0.4,
                0.6,
                0.8,
                1
            ];
            var coords = [];
            for (var i = 0; ad.scalar.lt(i, ts.length); i++) {
                coords.push(interpolate(ts[i], 3, [{
                        x: 0,
                        y: 0
                    }].concat(controlPoints)));
            }
            var delX = ad.scalar.sub(startPoint.x, coords[0].x);
            var delY = ad.scalar.sub(startPoint.y, coords[0].y);
            for (var i = 0; ad.scalar.lt(i, ts.length); i++) {
                coords[i].x = ad.scalar.mul(width, ad.scalar.add(coords[i].x, delX));
                coords[i].y = ad.scalar.mul(width, ad.scalar.add(coords[i].y, delY));
            }
            for (var i = 0; ad.scalar.lt(i, ad.scalar.sub(ts.length, 1)); i++) {
                out = drawLine(out, coords[i], coords[ad.scalar.add(i, 1)], linewidth, alpha);
            }
            return out;
        };
        var spatialTransformer = function (adcanvas, w, h, transformation) {
            var oldw = ad.value(adcanvas.t).dims[1];
            var oldh = ad.value(adcanvas.t).dims[2];
            var W = {
                ax: ad.scalar.div(ad.scalar.mul(transformation.ax, w), oldw),
                bx: ad.scalar.mul(transformation.bx, w),
                ay: ad.scalar.div(ad.scalar.mul(transformation.ay, h), oldh),
                by: ad.scalar.mul(transformation.by, h)
            };
            var pixels = [];
            var overlap = adcanvas.overlap;
            for (var y = 0; ad.scalar.lt(y, h); y++) {
                for (var x = 0; ad.scalar.lt(x, w); x++) {
                    var pre = {
                        x: ad.scalar.div(ad.scalar.sub(x, W.bx), W.ax),
                        y: ad.scalar.div(ad.scalar.sub(y, W.by), W.ay)
                    };
                    var lower = {
                        x: ad.scalar.floor(pre.x),
                        y: ad.scalar.floor(pre.y)
                    };
                    var upper = {
                        x: ad.scalar.add(lower.x, 1),
                        y: ad.scalar.add(lower.y, 1)
                    };
                    var rem = {
                        x: ad.scalar.sub(pre.x, lower.x),
                        y: ad.scalar.sub(pre.x, lower.x)
                    };
                    var lx = ad.value(lower.x);
                    var ux = ad.value(upper.x);
                    var ly = ad.value(lower.y);
                    var uy = ad.value(upper.y);
                    var v00 = 0, v01 = 0, v10 = 0, v11 = 0;
                    if (ad.scalar.geq(lx, 0) && ad.scalar.lt(lx, oldw) && ad.scalar.geq(ly, 0) && ad.scalar.lt(ly, oldh)) {
                        v00 = ad.tensor.get(adcanvas.t, ad.scalar.add(lx, ad.scalar.mul(oldw, ly)));
                    }
                    if (ad.scalar.geq(lx, 0) && ad.scalar.lt(lx, oldw) && ad.scalar.geq(uy, 0) && ad.scalar.lt(uy, oldh)) {
                        v01 = ad.tensor.get(adcanvas.t, ad.scalar.add(lx, ad.scalar.mul(oldw, uy)));
                    }
                    if (ad.scalar.geq(ux, 0) && ad.scalar.lt(ux, oldw) && ad.scalar.geq(ly, 0) && ad.scalar.lt(ly, oldh)) {
                        v10 = ad.tensor.get(adcanvas.t, ad.scalar.add(ux, ad.scalar.mul(oldw, ly)));
                    }
                    if (ad.scalar.geq(ux, 0) && ad.scalar.lt(ux, oldw) && ad.scalar.geq(uy, 0) && ad.scalar.lt(uy, oldh)) {
                        v11 = ad.tensor.get(adcanvas.t, ad.scalar.add(ux, ad.scalar.mul(oldw, uy)));
                    }
                    var val = ad.scalar.add(ad.scalar.add(ad.scalar.add(ad.scalar.mul(ad.scalar.mul(v00, ad.scalar.sub(1, rem.x)), ad.scalar.sub(1, rem.y)), ad.scalar.mul(ad.scalar.mul(v01, ad.scalar.sub(1, rem.x)), rem.y)), ad.scalar.mul(ad.scalar.mul(v10, ad.scalar.sub(1, rem.x)), rem.y)), ad.scalar.mul(ad.scalar.mul(v11, rem.x), rem.y));
                    pixels.push(val);
                }
            }
            var vector = ad.tensor.fromScalars(pixels);
            var output = ad.tensor.reshape(vector, [
                1,
                w,
                h
            ]);
            return { t: output };
        };
        var BmpDecoder = function (buffer) {
            this.pos = 0;
            this.buffer = buffer;
            this.flag = this.buffer.toString('utf-8', 0, this.pos += 2);
            if (this.flag != 'BM')
                throw new Error('Invalid BMP File');
            this.parseHeader();
            this.parseData();
        };
        BmpDecoder.prototype.parseHeader = function () {
            this.fileSize = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.reserved = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.offset = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.headerSize = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.width = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.height = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.planes = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.bitPP = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.compress = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.rawSize = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.hr = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.vr = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.colors = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
            this.importantColors = this.buffer.readUIntwidthLE(this.pos);
            this.pos += 4;
        };
        BmpDecoder.prototype.parseData = function () {
            this.pos = this.offset;
            this.data = new Tensor([
                1,
                this.width,
                this.height
            ]);
            for (var x = this.width - 1; x >= 0; x--) {
                for (var y = 0; y < this.height; y++) {
                    var value = this.buffer.readUInt8(this.pos);
                    this.data.set([
                        0,
                        x,
                        y
                    ], value / 255);
                    this.pos += 3;
                }
                this.pos += this.width % 4;
            }
        };
        BmpDecoder.prototype.getData = function () {
            return this.data;
        };
        var loadImage = function (path) {
            var bmpBuffer = fs.readFileSync(path);
            var decoder = new BmpDecoder(bmpBuffer);
            return { t: decoder.getData() };
        };
        var countval = -1;
        var counter = function (inc) {
            if (inc) {
                countval++;
            }
            return countval;
        };
        var error = function () {
            throw new Error('error!');
        };
        var getDate = function () {
            return new Date().toLocaleTimeString();
        };
        var omniglotFiles = fs.readdirSync('32x32/');
        var randomOmniglot = function () {
            var i = Math.floor(Math.random() * omniglotFiles.length);
            var name = omniglotFiles[i];
            var path = '32x32/' + name;
            var obs = loadImage(path);
            return {
                name: name,
                obs: obs
            };
        };
        var emptyCanvas = fill(width, width, 0);
        var fakeStrokes = [];
        for (var i = 0; i < 4; i++) {
            var p1 = {
                x: 0,
                y: 0
            };
            var p2 = {
                x: p1.x + 0.3 * Math.random() - 0.15 + 0.2 * Math.sin(i * Math.PI / 2),
                y: p1.y + 0.3 * Math.random() - 0.15 + 0.2 * Math.cos(i * Math.PI / 2)
            };
            var p3 = {
                x: p2.x + 0.3 * Math.random() - 0.15 + 0.2 * Math.sin(i * Math.PI / 2),
                y: p2.y + 0.3 * Math.random() - 0.15 + 0.2 * Math.cos(i * Math.PI / 2)
            };
            fakeStrokes[i] = [
                p1,
                p2,
                p3
            ];
        }
        var fakeOmniglot = function () {
            var idx1 = Math.floor(Math.random() * 4);
            var idx2 = Math.floor(Math.random() * 4);
            var d1 = getEnd({
                x: 0,
                y: 0
            }, fakeStrokes[idx1]);
            var pos2 = {
                x: Math.random() * 0.4 + 0.3,
                y: Math.random() * 0.4 + 0.3
            };
            var pos1 = {
                x: pos2.x - d1.x,
                y: pos2.y - d1.y
            };
            var out1 = drawStroke(emptyCanvas, pos1, fakeStrokes[idx1], 1.3, 1);
            var out2 = drawStroke(out1, pos2, fakeStrokes[idx2], 1.3, 1);
            return {
                name: idx1 + 'at' + pos1.x + ',' + pos1.y + ' ' + idx2 + 'at' + pos2.x + ',' + pos2.y,
                obs: out2
            };
        };
        return {
            fill,
            drawLine,
            saveImage,
            saveOverlay,
            gaussianKernel,
            convolve,
            drawStroke,
            powKernel,
            loadImage,
            counter,
            error,
            getDate,
            spatialTransformer,
            randomOmniglot,
            fakeOmniglot
        };
    }
};
function interpolate(t, order, points, knots, weights, result) {
    var i, j, s, l;
    var n = points.length;
    var d = 2;
    if (ad.scalar.lt(order, 2))
        throw new Error('order must be at least 2 (linear)');
    if (ad.scalar.gt(order, n))
        throw new Error('order must be less than point count');
    if (!weights) {
        weights = [];
        for (i = 0; ad.scalar.lt(i, n); i++) {
            weights[i] = 1;
        }
    }
    if (!knots) {
        var knots = [];
        for (i = 0; ad.scalar.lt(i, ad.scalar.add(n, order)); i++) {
            knots[i] = i;
        }
    } else {
        if (ad.scalar.pneq(knots.length, ad.scalar.add(n, order)))
            throw new Error('bad knot vector length');
    }
    var domain = [
        ad.scalar.sub(order, 1),
        ad.scalar.sub(ad.scalar.sub(knots.length, 1), ad.scalar.sub(order, 1))
    ];
    var low = knots[domain[0]];
    var high = knots[domain[1]];
    t = ad.scalar.add(ad.scalar.mul(t, ad.scalar.sub(high, low)), low);
    if (ad.scalar.lt(t, low) || ad.scalar.gt(t, high))
        throw new Error('out of bounds');
    for (s = domain[0]; ad.scalar.lt(s, domain[1]); s++) {
        if (ad.scalar.geq(t, knots[s]) && ad.scalar.leq(t, knots[ad.scalar.add(s, 1)])) {
            break;
        }
    }
    var v = [];
    for (i = 0; ad.scalar.lt(i, n); i++) {
        v[i] = {
            x: ad.scalar.mul(points[i].x, weights[i]),
            y: ad.scalar.mul(points[i].y, weights[i]),
            weight: weights[i]
        };
    }
    var alpha;
    for (l = 1; ad.scalar.leq(l, order); l++) {
        for (i = s; ad.scalar.gt(i, ad.scalar.add(ad.scalar.sub(s, order), l)); i--) {
            alpha = ad.scalar.div(ad.scalar.sub(t, knots[i]), ad.scalar.sub(knots[ad.scalar.sub(ad.scalar.add(i, order), l)], knots[i]));
            v[i].x = ad.scalar.add(ad.scalar.mul(ad.scalar.sub(1, alpha), v[ad.scalar.sub(i, 1)].x), ad.scalar.mul(alpha, v[i].x));
            v[i].y = ad.scalar.add(ad.scalar.mul(ad.scalar.sub(1, alpha), v[ad.scalar.sub(i, 1)].y), ad.scalar.mul(alpha, v[i].y));
            v[i].weight = ad.scalar.add(ad.scalar.mul(ad.scalar.sub(1, alpha), v[ad.scalar.sub(i, 1)].weight), ad.scalar.mul(alpha, v[i].weight));
        }
    }
    result = {
        x: ad.scalar.div(v[s].x, v[s].weight),
        y: ad.scalar.div(v[s].y, v[s].weight)
    };
    return result;
}